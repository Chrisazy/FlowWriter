//  (c) Copyright 2013 Hewlett-Packard Development Company, L.P.
//  Autogenerated
package com.purdue.fw.impl;

import static com.hp.of.lib.instr.ActionType.OUTPUT;
import static com.hp.of.lib.match.FieldFactory.createBasicField;
import static com.hp.of.lib.match.OxmBasicFieldType.ETH_TYPE;
import static com.hp.of.lib.match.OxmBasicFieldType.IPV4_DST;
import static com.hp.of.lib.match.OxmBasicFieldType.IPV4_SRC;
import static com.hp.of.lib.match.OxmBasicFieldType.IP_PROTO;
import static com.hp.of.lib.match.OxmBasicFieldType.TCP_DST;
import static com.hp.of.lib.match.OxmBasicFieldType.TCP_SRC;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.Set;

import org.apache.felix.scr.annotations.Component;
import org.apache.felix.scr.annotations.Reference;
import org.apache.felix.scr.annotations.ReferenceCardinality;
import org.apache.felix.scr.annotations.ReferencePolicy;
import org.apache.felix.scr.annotations.Service;
import org.pcap4j.core.NotOpenException;
import org.pcap4j.core.PcapDumper;
import org.pcap4j.core.PcapHandle;
import org.pcap4j.core.PcapNativeException;

import com.hp.of.ctl.ControllerService;
import com.hp.of.ctl.DataPathEvent;
import com.hp.of.ctl.DataPathListener;
import com.hp.of.ctl.ErrorEvent;
import com.hp.of.ctl.QueueEvent;
import com.hp.of.ctl.pkt.MessageContext;
import com.hp.of.ctl.pkt.PacketListenerRole;
import com.hp.of.ctl.pkt.SequencedPacketListener;
import com.hp.of.lib.OpenflowException;
import com.hp.of.lib.ProtocolVersion;
import com.hp.of.lib.dt.DataPathInfo;
import com.hp.of.lib.instr.ActOutput;
import com.hp.of.lib.instr.ActionFactory;
import com.hp.of.lib.match.Match;
import com.hp.of.lib.match.MatchFactory;
import com.hp.of.lib.match.MutableMatch;
import com.hp.of.lib.msg.FlowModCommand;
import com.hp.of.lib.msg.MessageFactory;
import com.hp.of.lib.msg.MessageType;
import com.hp.of.lib.msg.OfmFlowMod;
import com.hp.of.lib.msg.OfmMutableFlowMod;
import com.hp.of.lib.msg.Port;
import com.hp.util.ip.EthernetType;
import com.hp.util.ip.IpAddress;
import com.hp.util.ip.IpProtocol;
import com.hp.util.ip.PortNumber;
import com.hp.util.pkt.Ip;
import com.hp.util.pkt.Packet;
import com.hp.util.pkt.ProtocolId;
import com.purdue.fw.api.InvalidInputException;
import com.purdue.fw.api.PacketService;
import com.sun.jersey.core.util.Base64;

/**
 * Sample Packet service implementation.
 */
@Component(immediate = true)
@Service
public class PacketManager implements PacketService, SequencedPacketListener, DataPathListener {

	private static final long COOKIE = 0x13374468;
	private static final int FLOW_IDLE_TIMEOUT = 300;
	private static final int FLOW_HARD_TIMEOUT = 600;
	private static final int FLOW_PRIORITY = 30000;

	private String src = null;
	private String dst = null;
	private int srcport = -1;
	private int dstport = -1;
	private ArrayList<byte[]> capturedPackets;
	PcapDumper dumper;
	
	

	private static final ProtocolVersion PV = ProtocolVersion.V_1_0;

	@Reference(name = "ControllerService", cardinality = ReferenceCardinality.OPTIONAL_UNARY, policy = ReferencePolicy.DYNAMIC)
	private ControllerService cs;
	final protected static char[] hexArray = "0123456789ABCDEF".toCharArray();
	private static final String IPADDRESS_PATTERN = "^([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\."
			+ "([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\."
			+ "([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\."
			+ "([01]?\\d\\d?|2[0-4]\\d|25[0-5])$";

	public static String bytesToHex(byte[] bytes) {
		char[] hexChars = new char[bytes.length * 2];
		for (int j = 0; j < bytes.length; j++) {
			int v = bytes[j] & 0xFF;
			hexChars[j * 2] = hexArray[v >>> 4];
			hexChars[j * 2 + 1] = hexArray[v & 0x0F];
		}
		return new String(hexChars);
	}

	private Match createMatch(IpAddress ip_src, IpAddress ip_dst,
			PortNumber src_port, PortNumber dst_port) {
		MutableMatch mm = MatchFactory.createMatch(PV)
				.addField(createBasicField(PV, ETH_TYPE, EthernetType.IPv4))
				.addField(createBasicField(PV, IP_PROTO, IpProtocol.TCP))
				.addField(createBasicField(PV, TCP_SRC, src_port))
				.addField(createBasicField(PV, TCP_DST, dst_port))
				.addField(createBasicField(PV, IPV4_SRC, ip_src))
				.addField(createBasicField(PV, IPV4_DST, ip_dst));

		return (Match) mm.toImmutable();
	}

	public OfmFlowMod createFlowMod(String ip_src, String ip_dst, int src_port,
			int dst_port) throws InvalidInputException {
		// Check the input
		if (ip_src == null || !ip_src.matches(IPADDRESS_PATTERN))
			throw new InvalidInputException("IP_SRC", ip_src);
		else if (ip_dst == null || !ip_dst.matches(IPADDRESS_PATTERN))
			throw new InvalidInputException("IP_DST", ip_dst);
		if (src_port < 1 || src_port > 65535)
			throw new InvalidInputException("SRC_PORT", src_port + "");
		if (dst_port < 1 || dst_port > 65535)
			throw new InvalidInputException("DST_PORT", dst_port + "");

		// Create a 1.0 FlowMod ADD message...
		OfmMutableFlowMod fm = (OfmMutableFlowMod) MessageFactory.create(PV,
				MessageType.FLOW_MOD, FlowModCommand.ADD);
		fm.cookie(COOKIE)
				.priority(FLOW_PRIORITY)
				.idleTimeout(FLOW_IDLE_TIMEOUT)
				.hardTimeout(FLOW_HARD_TIMEOUT)
				.match(createMatch(IpAddress.valueOf(ip_src),
						IpAddress.valueOf(ip_dst),
						PortNumber.valueOf(src_port),
						PortNumber.valueOf(dst_port)));

		fm.addAction(ActionFactory.createAction(PV, OUTPUT, Port.CONTROLLER,
				ActOutput.CONTROLLER_MAX));
		fm.addAction(ActionFactory.createAction(PV, OUTPUT, Port.NORMAL,
				ActOutput.CONTROLLER_NO_BUFFER));
		return (OfmFlowMod) fm.toImmutable();
	}

	public void sendMod(OfmFlowMod flowMod) throws InvalidInputException,
			OpenflowException {
		Set<DataPathInfo> datapathIds = cs.getAllDataPathInfo();
		for (DataPathInfo dataPathId : datapathIds) {
			cs.sendFlowMod(flowMod, dataPathId.dpid());
		}
	}

	/*
	 * Wrapper for the REST API to consume easily without needing to know or
	 * care what FlowMods are
	 */
	public void createAndSendMod(String ip_src, String ip_dst, int src_port,
			int dst_port) throws InvalidInputException, OpenflowException {
		this.src = ip_src;
		this.dst = ip_dst;
		this.srcport = src_port;
		this.dstport = dst_port;
		this.capturedPackets = new ArrayList<byte[]>();
		sendMod(createFlowMod(ip_src, ip_dst, src_port, dst_port));
		sendMod(createFlowMod(ip_dst, ip_src, dst_port, src_port));
	}

	private String encodeFileToBase64Binary(File file){
	    String encodedfile = null;
	    try {
	        FileInputStream fileInputStreamReader = new FileInputStream(file);
	        byte[] bytes = new byte[(int)file.length()];
	        fileInputStreamReader.read(bytes);
	        encodedfile = Base64.encode(bytes).toString();
	        fileInputStreamReader.close();
	    } catch (FileNotFoundException e) {
	        // TODO Auto-generated catch block
	        e.printStackTrace();
	    } catch (IOException e) {
	        // TODO Auto-generated catch block
	        e.printStackTrace();
	    }
	    return encodedfile;
	}
	
	public String stopCapture(String ip_src, String ip_dst, int src_port,
			int dst_port) throws InvalidInputException, OpenflowException {
		// Check the input
		if (ip_src == null || !ip_src.matches(IPADDRESS_PATTERN))
			throw new InvalidInputException("IP_SRC", ip_src);
		else if (ip_dst == null || !ip_dst.matches(IPADDRESS_PATTERN))
			throw new InvalidInputException("IP_DST", ip_dst);
		if (src_port < 1 || src_port > 65535)
			throw new InvalidInputException("SRC_PORT", src_port + "");
		if (dst_port < 1 || dst_port > 65535)
			throw new InvalidInputException("DST_PORT", dst_port + "");
		
		// TODO: Remove listeners and flows
		
		try {
			PcapHandle handle = (new PcapHandle.Builder(null)).build();
			long time = System.currentTimeMillis();
			String filename = "fw-"+time+".pcap";
			PcapDumper dumper = handle.dumpOpen(filename);
			for(byte[] p : capturedPackets) {
				dumper.dumpRaw(p);
			}
			dumper.close();
			handle.close();
			
			File f = new File(filename);
			String s = encodeFileToBase64Binary(f);
			return s;
			
			
		} catch (PcapNativeException e) {
			e.printStackTrace();
		} catch (NotOpenException e) {
			e.printStackTrace();
		}
		
		return null;
	}

	
	/* Bind the controller service. */
	protected void bindControllerService(ControllerService cs) {
		System.out.println("PFW: Binding the cs!");
		if (this.cs != null) {
			System.out.println("PFW: We already had one, though..");
			return;
		}
		this.cs = cs;
		cs.addPacketListener(this, PacketListenerRole.OBSERVER, 5000,
				EnumSet.of(ProtocolId.TCP, ProtocolId.UDP));
		cs.addDataPathListener(this);
	}

	/* Unbind the controller service. */
	protected void unbindControllerService(ControllerService cs) {
		if (this.cs == cs) {
			this.cs.removePacketListener(this);
			this.cs = null;
		}
	}

	@Override
	public void errorEvent(ErrorEvent e) {
		System.err.println("MYAPPERR: ERROR - " + e.text());
	}

	@Override
	public void event(MessageContext msg) {
		System.out.println("PFW: Received msg");
		Packet p = msg.decodedPacket();
		if (!p.has(ProtocolId.IP)) {
			return;
		}
		Ip ip = p.get(ProtocolId.IP);
		String src_ip = ip.srcAddr().toString();
		String dst_ip = ip.dstAddr().toString();
		if(src == null || dst == null)
			return;
		if ((src_ip.equals(src) && dst_ip.equals(dst))
				|| (src_ip.equals(src) && dst_ip.equals(dst))) {

			System.out.println("PFWMAP4: "
					+ bytesToHex(msg.getPacketIn().getData()));
			capturedPackets.add(msg.getPacketIn().getData());
		}
	}

	@Override
	public void event(DataPathEvent e) {
		if (!cs.isHybridMode())
			return;
		try {
			cs.sendFlowMod(createFlowMod(src, dst, srcport, dstport), e.dpid());
			cs.sendFlowMod(createFlowMod(dst, src, dstport, srcport), e.dpid());
		} catch (OpenflowException e1) {
			e1.printStackTrace();
		} catch (InvalidInputException e1) {
			// Probably just means that there's no input yet, but either way,
			// nothing to see here..
			System.err.println("Purdue's Flow Writer: Invalid input");
			System.err.println("\t" + e1.name + ": " + e1.value);
		}
	}

	@Override
	public void queueEvent(QueueEvent arg0) {

	}
}
