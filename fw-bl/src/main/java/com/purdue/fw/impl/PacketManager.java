//  (c) Copyright 2013 Hewlett-Packard Development Company, L.P.
//  Autogenerated
package com.purdue.fw.impl;

import static com.hp.of.lib.instr.ActionType.OUTPUT;
import static com.hp.of.lib.match.FieldFactory.createBasicField;
import static com.hp.of.lib.match.OxmBasicFieldType.ETH_TYPE;
import static com.hp.of.lib.match.OxmBasicFieldType.IPV4_DST;
import static com.hp.of.lib.match.OxmBasicFieldType.IPV4_SRC;
import static com.hp.of.lib.match.OxmBasicFieldType.IP_PROTO;
import static com.hp.of.lib.match.OxmBasicFieldType.TCP_DST;
import static com.hp.of.lib.match.OxmBasicFieldType.TCP_SRC;

import java.util.ArrayList;
import java.util.EnumSet;
import java.util.Set;

import com.purdue.fw.api.PacketService;
import org.apache.felix.scr.annotations.Component;
import org.apache.felix.scr.annotations.Reference;
import org.apache.felix.scr.annotations.ReferenceCardinality;
import org.apache.felix.scr.annotations.ReferencePolicy;

import com.hp.of.ctl.ControllerService;
import com.hp.of.ctl.DataPathEvent;
import com.hp.of.ctl.DataPathListener;
import com.hp.of.ctl.ErrorEvent;
import com.hp.of.ctl.QueueEvent;
import com.hp.of.ctl.pkt.MessageContext;
import com.hp.of.ctl.pkt.PacketListenerRole;
import com.hp.of.ctl.pkt.SequencedPacketListener;
import com.hp.of.lib.OpenflowException;
import com.hp.of.lib.ProtocolVersion;
import com.hp.of.lib.dt.DataPathInfo;
import com.hp.of.lib.instr.ActOutput;
import com.hp.of.lib.instr.ActionFactory;
import com.hp.of.lib.match.Match;
import com.hp.of.lib.match.MatchFactory;
import com.hp.of.lib.match.MutableMatch;
import com.hp.of.lib.msg.FlowModCommand;
import com.hp.of.lib.msg.MessageFactory;
import com.hp.of.lib.msg.MessageType;
import com.hp.of.lib.msg.OfmFlowMod;
import com.hp.of.lib.msg.OfmMutableFlowMod;
import com.hp.of.lib.msg.Port;
import com.hp.util.ip.EthernetType;
import com.hp.util.ip.IpAddress;
import com.hp.util.ip.IpProtocol;
import com.hp.util.ip.PortNumber;
import com.hp.util.pkt.Ip;
import com.hp.util.pkt.Packet;
import com.hp.util.pkt.ProtocolId;
import org.apache.felix.scr.annotations.Service;

/**
 * Sample Packet service implementation.
 */
@Component(metatype=true)
@Service
public class PacketManager implements PacketService, SequencedPacketListener, DataPathListener {

	private static final long COOKIE = 0x13374468;
	private static final int FLOW_IDLE_TIMEOUT = 300;
	private static final int FLOW_HARD_TIMEOUT = 600;
	private static final int FLOW_PRIORITY = 30000;

	private String ip_src = null;
	private String ip_dst = null;
	private int port_src = -1;
	private int port_dst = -1;
	private ArrayList<byte[]> capturedPackets;
	
	

	private static final ProtocolVersion PV = ProtocolVersion.V_1_0;

	@Reference(name = "ControllerService", cardinality = ReferenceCardinality.OPTIONAL_UNARY, policy = ReferencePolicy.DYNAMIC)
	private ControllerService cs;
	final protected static char[] hexArray = "0123456789ABCDEF".toCharArray();
	private static final String IPADDRESS_PATTERN = "^([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\."
			+ "([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\."
			+ "([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\."
			+ "([01]?\\d\\d?|2[0-4]\\d|25[0-5])$";

	public static String bytesToHex(byte[] bytes) {
		char[] hexChars = new char[bytes.length * 2];
		for (int j = 0; j < bytes.length; j++) {
			int v = bytes[j] & 0xFF;
			hexChars[j * 2] = hexArray[v >>> 4];
			hexChars[j * 2 + 1] = hexArray[v & 0x0F];
		}
		return new String(hexChars);
	}

	private Match createMatch(IpAddress ip_src, IpAddress ip_dst,
			PortNumber port_src, PortNumber port_dst) {
		MutableMatch mm = MatchFactory.createMatch(PV)
				.addField(createBasicField(PV, ETH_TYPE, EthernetType.IPv4))
				.addField(createBasicField(PV, IP_PROTO, IpProtocol.TCP))
				.addField(createBasicField(PV, IP_PROTO, IpProtocol.UDP))
				.addField(createBasicField(PV, IP_PROTO, IpProtocol.ICMP))
				.addField(createBasicField(PV, TCP_SRC, port_src))
				.addField(createBasicField(PV, TCP_DST, port_dst))
				.addField(createBasicField(PV, IPV4_SRC, ip_src))
				.addField(createBasicField(PV, IPV4_DST, ip_dst));

		return (Match) mm.toImmutable();
	}

	public OfmFlowMod createFlowMod(String ip_src, String ip_dst, int port_src,
			int port_dst) throws Exception {
		// Check the input
        if (ip_src == null || !ip_src.matches(IPADDRESS_PATTERN))
            throw new Exception( "IP_SRC: " + ip_src);
        else if (ip_dst == null || !ip_dst.matches(IPADDRESS_PATTERN))
            throw new Exception( "IP_DST: " + ip_dst);
        if (port_src < 1 || port_src > 65535)
            throw new Exception("PORT_SRC: " + port_src);
        if (port_dst < 1 || port_dst > 65535)
            throw new Exception("PORT_DST: " + port_dst);

		// Create a 1.0 FlowMod ADD message...
		OfmMutableFlowMod fm = (OfmMutableFlowMod) MessageFactory.create(PV,
				MessageType.FLOW_MOD, FlowModCommand.ADD);
		fm.cookie(COOKIE)
				.priority(FLOW_PRIORITY)
				.idleTimeout(FLOW_IDLE_TIMEOUT)
				.hardTimeout(FLOW_HARD_TIMEOUT)
				.match(createMatch(IpAddress.valueOf(ip_src),
						IpAddress.valueOf(ip_dst),
						PortNumber.valueOf(port_src),
						PortNumber.valueOf(port_dst)));

		fm.addAction(ActionFactory.createAction(PV, OUTPUT, Port.CONTROLLER,
				ActOutput.CONTROLLER_MAX));
		fm.addAction(ActionFactory.createAction(PV, OUTPUT, Port.NORMAL,
				ActOutput.CONTROLLER_NO_BUFFER));
		return (OfmFlowMod) fm.toImmutable();
	}

	public void sendMod(OfmFlowMod flowMod) throws Exception,
			OpenflowException {
		Set<DataPathInfo> datapathIds = cs.getAllDataPathInfo();
		for (DataPathInfo dataPathId : datapathIds) {
			cs.sendFlowMod(flowMod, dataPathId.dpid());
		}
	}

	/*
	 * Wrapper for the REST API to consume easily without needing to know or
	 * care what FlowMods are
	 */
	public void createAndSendMod(String ip_src, String ip_dst, int src_port,
			int dst_port) throws Exception, OpenflowException {
		this.ip_src = ip_src;
		this.ip_dst = ip_dst;
		this.port_src = src_port;
		this.port_dst = dst_port;
		this.capturedPackets = new ArrayList<byte[]>();
		sendMod(createFlowMod(ip_src, ip_dst, src_port, dst_port));
		sendMod(createFlowMod(ip_dst, ip_src, dst_port, src_port));
	}

	public String stopCapture(String ip_src, String ip_dst, int port_src,
			int port_dst) throws Exception, OpenflowException {
		// Check the input
		if (ip_src == null || !ip_src.matches(IPADDRESS_PATTERN))
			throw new Exception( "IP_SRC: " + ip_src);
		else if (ip_dst == null || !ip_dst.matches(IPADDRESS_PATTERN))
            throw new Exception( "IP_DST: " + ip_dst);
		if (port_src < 1 || port_src > 65535)
            throw new Exception("PORT_SRC: " + port_src);
		if (port_dst < 1 || port_dst > 65535)
            throw new Exception("PORT_DST: " + port_dst);

		return null;
	}

	/* Bind the controller service. */
	protected void bindControllerService(ControllerService cs) {
		System.out.println("PFW: Binding the cs!");
		if (this.cs != null) {
			System.out.println("PFW: We already had one, though..");
			return;
		}
		this.cs = cs;
		cs.addPacketListener(this, PacketListenerRole.OBSERVER, 5000,
				EnumSet.of(ProtocolId.TCP, ProtocolId.UDP));
		cs.addDataPathListener(this);
	}

	/* Unbind the controller service. */
	protected void unbindControllerService(ControllerService cs) {
		if (this.cs == cs) {
			this.cs.removePacketListener(this);
			this.cs = null;
		}
	}

	@Override
	public void errorEvent(ErrorEvent e) {
		System.err.println("MYAPPERR: ERROR - " + e.text());
	}

	@Override
	public void event(MessageContext msg) {
		System.out.println("PFW: Received msg");
		Packet p = msg.decodedPacket();
		if (!p.has(ProtocolId.IP)) {
			return;
		}
		Ip ip = p.get(ProtocolId.IP);
		String src_ip = ip.srcAddr().toString();
		String dst_ip = ip.dstAddr().toString();
		if(ip_src == null || ip_dst == null)
			return;
		if ((src_ip.equals(ip_src) && dst_ip.equals(ip_dst))
				|| (src_ip.equals(ip_src) && dst_ip.equals(ip_dst))) {

			System.out.println("PFWMAP4: "
					+ bytesToHex(msg.getPacketIn().getData()));
			capturedPackets.add(msg.getPacketIn().getData());
		}
	}

	@Override
	public void event(DataPathEvent e) {
		if (!cs.isHybridMode())
			return;
		try {
			cs.sendFlowMod(createFlowMod(ip_src, ip_dst, port_src, port_dst), e.dpid());
			cs.sendFlowMod(createFlowMod(ip_dst, ip_src, port_dst, port_src), e.dpid());
		} catch (OpenflowException e1) {
			e1.printStackTrace();
		} catch (Exception e1) {
			// Probably just means that there's no input yet, but either way,
			// nothing to see here..
			System.err.println("Purdue's Flow Writer: Invalid input");
			System.err.println("\t" + e1.toString());
		}
	}

	@Override
	public void queueEvent(QueueEvent arg0) {

	}
}
